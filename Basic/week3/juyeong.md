# 3. 영속성 관리

## JPA에서 중요한 것
- 객체와 관계형데이터베이스 매핑
- 실제 jpa가 내부에서 어떻게 동작하는지 -> 영속성 컨텍스트
- 엔티티매니저 팩토리 & 엔티티 매니저

## 영속성 컨텍스트
"엔티티를 영구 저장하는 환경" 
- 논리적인 개념으로, 눈에 보이지 않아. 이걸 공부하는 이유는 JPA 내부 동작원리를 알고 사용하기 위함임.
- 엔티티 매니저를 생성하면 영속성 컨텍스트가 생성된다.

## 엔티티의 생명주기
1. new : 영속성 컨텍스트와 관계없는 새로운 상태
2. managed : 관리되는 상태
3. detached : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. removed : 삭제된 상태

🔥 영속 상태에 들어갔다고 db에 저장되는 것은 아니다. 애플리케이션과 디비 사이에 이 계층을 둬서 머가 좋냐.. 버퍼링, 캐싱 같은 이점을 누릴 수 있음.

# 영컨텍의 이점
## 1.1차 캐시
영속성 컨텍스트(Entitiy Manager)는 내부에 1차 캐시를 두고 있음
- find할 때 영.컨텍스트에 없으면 디비에서 조회하고~ 없으면 생성함.
- 근데 1차캐시가 중요한가? 어차피 트랜잭션 끝나면 삭제됨. 어플리케이션 전체에서 공유되는 것은 2차 캐시임
- 영속 엔티티의 동일성 보장도, 1차 캐시때문에 가능함.
  
## 2.엔티티 등록 시, 트랜잭션을 지원하는 쓰기 지연
- 인서트하면 디비에 바로 넣는게 아니라
- 엔티티매니저에는 영.컨만 있는게 아니라 "쓰기 지연 sql 저장소"도 있음. 여기에 쿼리를 쌓아두다가 트랜잭션 커밋되면 넣음. 객체는 1차 캐시에, 쿼리는 쓰기지연 저장소에 넣슴니다
- 여기서 트랜잭션 커밋을 "플러시"라고 한다.
- JPA는 내부적으로 리플렉션 사용하고 그래서 동적이라
- 기본 생성자 만들어주고 tx.commit() 진행해야함.

![영컨텍 내부](https://velog.velcdn.com/cloudflare/seungho1216/06fb89f1-62dd-4447-81f0-66d469e0c5b2/%EC%98%81%EC%86%8D%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%A0%84%EC%B2%B4.png)



## 3.배치(버퍼링)
- database.batch 사이즈를 설정에서 조정할 수 있는데, 이를 버퍼링 혹은 배치라고 한다.
- 설정 옵션하나로 쿼리 모았다가 한번에 넣으므로 성능을 향상시킬 수 있다는 점이 이점!

## 4.엔티티 수정(더티 체킹) 
- JPA는 자바 컬렉션처럼 객체를 다루게 한다.
- 찾고(find), 변경(set)한 다음에 persist 안해도 된다. -> 자바 컬렉션에 값 변경하고 다시 업데이트 쿼리(혹은 코드) 안날리는 것 생각하면 된다! 
- 더티 체킹 == 변경감지!
- JPA는 변경감지를 인지해서 디비 값을 변경한다!!!!!
- 이걸 어케하냐면.. 영속성 컨텍스트 안에 정답이 있다.
- 커밋하면 -> 플러시 호출 -> 1차 캐시 안의 엔티티/ 스냅샷(값을 읽어온 최초의 상태 캡쳐) 비교 ("엔티티는 이런데.. 스냅샷은 이렇네?!") -> 바뀐 것 감지하고 -> 업데이트 쿼리를 디비에 날리고 -> 커밋한다.
![스냅샷과 비교-더티체킹](https://velog.velcdn.com/cloudflare/seungho1216/06fb89f1-62dd-4447-81f0-66d469e0c5b2/%EC%98%81%EC%86%8D%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%A0%84%EC%B2%B4.png)

## 5.엔티티 삭제
- remove 하면 삭제된다.
  
## 플러시
- 영.컨텍의 변경내용(쿼리)을 데이터베이스에 반영 -> "동기화"가 목적임
- 플러시가 발생하면 
  - 1. 더티체킹
  - 2. 수정된 엔티티를 쓰기지연sql저장소에 등록
  - 3. 쓰기지연 저장소의 쿼리를 디비에 전송 (등록,수정,삭제)

- 영.컨텍을 어케 플러시하나요?
  - 1. em.flush() -> 직접호출 방식인데 거의 안씀
  - 2. 트랜잭션 커밋 -> 자동호출
  - 3. JPQL 쿼리 실행 -> 자동호출
  - 플러시를한다고 1차캐시가 지워지는 것이 아니고, 쓰기지연저장소에 쌓인 애들을 그냥 디비에 반영하는 것 뿐임

- 플러시 모드 옵션
  - 1. FlushModeType.AUTO : 디폴트, 커밋&쿼리 실행할 때 플러시. 대부분 그냥 이거 씀
  - 2. FlushModeType.COMMIT :  커밋할때만 플러시

- 트랜잭션 작업 단위가 중요하고 커밋 직전에 동기화가 되어야함 -> 동기화되기 때문에 1차캐시랑 디비랑 내용 다르면 어카지..하는 고민 안해도 됩니다

## 준영속 상태
- 영속 -> 준영속 상태가 되는것
  : 영속 상태의 엔티티가 영.컨텍에서 detached 되는 것, 영.컨텍 기능 사용 못함
- 어케 detach 하냐면..
  - 1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
  - 2. em.clear() : 영.컨텍을 완전히 초기화
  - 3. em.close() : 영.컨텍 종료
- 셀렉트 쿼리는 되지만 다른 쿼리는 못쓰겠지. 지금은 잘 몰라도 되지만 나중에 복잡해지면 필요함..


