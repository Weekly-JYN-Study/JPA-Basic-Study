# 8. 프록시와 연관관계 관리

- 프록시와 즉시로딩, 지연로딩:  
   JPA 구현체들은 프록시를 사용해 연관된 객체를 실제 사용하는 시점에 DB를 조회한다. 즉시로딩과 지연로딩을 사용해 프록시 지원.
- 영속성 전이와 고아 객체:  
   JPA는 연관객체를 함께 저장 또는 삭제할 수 있는 영속성 전이와 고아 객체 제거 기능 제공.

## 프록시

JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 지연 로딩을 지원한다.

지연 로딩을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체인 프록시 객체가 필요하다.

> JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임. 이하 하이버네이트에 대한 내용.

### 프록시 기초

JPA에서 식별자로 엔티티를 하나 조회할 때 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다. -> 조회한 엔티티의 실제 사용 여부 상관없이 DB를 조회하게 됨

엔티티 실제 사용 시점까지 데이터베이스 조회를 미루려면 `EntityManager.getReference()`를 사용하면 된다. -> 호출 시 JPA는 DB 조회X, 실제 엔티티 객체 생성X. 대신에 **DB 접근을 위임한 프록시 객체를 반환**한다.

`Member member = em.getReference(Member.class, "member1");`

#### 프록시 구조

프로시 클래스는 실제 클래스를 상속 받아 만들어져 실제 클래스와 겉 모양이 같다. 사용할 때는 구분 없이 사용하면 된다.

프록시 객체는 **실제 객체에 대한 참조(target)** 를 보관한다. 프록시 객체의 메소드를 호출하면 실제 객체의 메소드를 호출한다.

#### 프록시 객체의 초기화

프록시 객체의 초기화는 프록시 객체가 실제 사용될 때 DB를 조회해 실제 엔티티 객체를 생성하는 것을 의미한다.

#### 프록시 객체의 초기화 과정

1. 프록시 객체에 `member.getName()`을 호출해 실제 데이터를 조회.
2. 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는 **초기화**를 한다.
3. 영속성 컨텍스트는 DB를 조회해 실제 엔티티 객체를 생성.
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 멤버변수(`Member target`)에 보관한다.
5. 프록시 객체는 실제 엔티티의 메소드(`getName()`)를 호출해 결과를 반환한다.

#### 프록시의 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화 한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. **프록시 객체를 통해 실제 엔티티에 접근**하는 것이다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시 주의해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 준영속 상태의 프록시 초기화 시 예외 발생.

### 프록시와 식별자

엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 **식별자 값을 보관**한다.

`Team team = em.getReference(Team.class, "team1");`  
`team.getId() //초기화X`

그래서 식별자 값을 조회 하는 메소드를 호출해도(`team.getId()`) 프록시를 초기화하지 않는다. -> 엔티티 접근 방식을 **프로퍼티**로 설정한 경우에만 초기화X(`@Access(AccessType.PROPERTY)`)

엔티티 접근 방식을 **필드**(`@Access(AccessType.FILED)`)로 하면 JPA는 조회 메소드가 ID만 조회 하는지 다른 필드를 활용해 어떤 일을 하는지 알지 못하므로 프록시 객체를 초기화 한다.

**연관관계 설정**할 때 식별자 값만 사용하므로 **프록시를 사용**해 DB 접근횟수를 줄일 수 있다. 연관관계를 설정할 때는 엔티티 접근 방식을 필드로 해도 프록시를 초기화하지 않는다.

```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1"); //sql 실행X
member.setTeam(team);
```

### 프록시 확인

JPA가 제공하는 `PersistenceUnitUtil.isLoaded(Object entity)` 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다. 초기화 되지 않은 인스턴스는 false, 이미 초기화 되었거나 프록시 인스턴스가 아니면 true를 반환한다.

`boolean isLoad = em.getEntityManagerFactory().getPersistenceUnitUtil().isLoaded(entity);` 또는  
`boolean isLoad = emf.getPersistenceUnitUtil().isLoaded(entity);`

조회한 엔티티가 진짜인지 프록시로 조회한 것인지 확인하려면 클래스명을 직접 출력하면 된다. 클래스명 뒤가 `..javassist..`이면 프록시이다. (프록시 생성 라이브러리에 따라 달라질 수 있음)

## 즉시 로딩과 지연 로딩

프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.

JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 두 가지 방법을 제공한다.

- **즉시 로딩**: 엔티티를 조회할 때 연관된 엔티티도 함께 조회.
  - 예: `em.find(Member.class, "member1")`호출 시 회원엔티티와 연관된 엔티티(팀) 함께 조회.
  - 설정 방법: `@ManyToOne(fetch = FetchType.EAGER)`
- **지연 로딩**: 연관된 엔티티를 실제 사용할 때 조회.
  - 예: `member.getTeam().getName()`처럼 조회한 팀 엔티티를 실제 사용 시점에 JPA가 SQL을 호출해 팀 엔티티 조회.
  - 설정 방법: `@ManyToOne(fetch = FetchType.LAZY)`

### 즉시 로딩 EAGER LOADING

대부분의 JPA 구현체는 즉시 로딩 최적화 위해 가능하면 조인 쿼리를 사용한다.(연관된 테이블 수 만큼 조회 쿼리 실행X)

#### NULL 제약조건과 JPA 조인 전략

JPA는 기본 외부 조인을 사용한다. 내부 조인을 사용하려면 외래 키에 NOT NULL 제약 조건을 설정하고 내부 조인을 사용하면 된다.

JPA에도 `@JoinColumn`에 `nullable = false`를 설정하면 내부 조인을 사용한다. (또는 `@ManyToOne(optional = false)`)

- nullable 설정에 따른 조인 전략
  - `@JoinColumn(nullable = true)`: NULL 허용(기본값). 외부 조인
  - `@JoinColumn(nullable = false)`: NOT NULL. 내부 조인.

-> JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.

### 지연 로딩 LAZY LOADING

지연 로딩을 사용하면 엔티티 조회 시 자신만 조회 하고 연관된 엔티티의 멤버변수에 프록시 객체를 넣어둔다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. (이후 실제 사용 시 DB 조회 후 프록시 객체 초기화)

### 즉시 로딩, 지연 로딩 정리

연관된 엔티티를 즉시 로딩할지 지연 로딩할지는 상황에 따라 맞는 것을 선택해 사용하면 된다.

- **지연 로딩**: 연관된 엔티티를 프록시로 조회. 프록시 실제 사용할 때 초기화 하면서 DB를 조회.
- **즉시 로딩**: 연관된 엔티티 즉시 조회. 하이버네이트는 가능하면 SQL 조인 사용해 한 번에 조회.

## 지연 로딩 활용

- 연관된 엔티티를 자주 함께 사용 -> 즉시 로딩
- 연관된 엔티티를 가끔 사용 -> 지연 로딩

### 프록시와 컬렉션 래퍼

지연 로딩을 사용할 때 프록시 객체는 실제 자신이 사용될 때까지 DB를 조회하지 않는다.

하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 **컬렉션을 추적, 관리**할 목적으로 **컬렉션래퍼**를 사용한다. 컬렉션 래퍼는 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. (프록시 객체 대신 컬렉션래퍼가 지연 로딩 처리)

컬렉션은 컬렉션에서 실제 데이터를 조회할 때 DB를 조회해 초기화한다. (컬렉션 가져올 때 초기화X)

### JPA 기본 페치 전략

fetch 속성 기본 설정값

- `@ManyToOne, @OneToOne`: 즉시 로딩(`FetchType.EAGER`)
- `@OneToMany, @ManyToMany`: 지연 로딩(`FetchType.LAZY`)

JPA는 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다.

추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것. 애플리케이션 개발 완료 단계에서 필요 시 즉시 로딩을 사용하도록 최적화.

### 컬렉션에 FetchType.EAGER 사용 시 주의점

- **컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다**
  - 컬렉션과 조인은 DB 테이블로 보면 일대다 조인. 결과 데이터가 다 쪽 수만큼 증가함. -> 서로 다른 컬렉션을 두 개 이상 조인하면 성능 저하 -> 2개 이상의 컬렉션 즉시 로딩은 권장X
- **컬렉션 즉시 로딩을 항상 외부 조인을 사용한다.**
  - (N:1) 회원 테이블-> 팀 테이블 조인. 회원 테이블의 FK는 not null. 내부 조인 사용 가능. 반대로 (1:N) 팀 테이블 -> 회원 테이블 조인 시 회원이 없는 팀은 내부 조인 하면 팀이 조회되지 않음. -> JPA는 일대다 관계를 즉시 로딩할 때 항상 외부 조인 사용.

## 영속성 전이: CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 하려면 영속성 전이(transitive persistence)기능을 사용하면 된다. JPA는 CASCADE 옵션으로 영속성 전이를 제공.

JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다. 영속성 전이를 사용하면 부모만 영속 상태로 만들면 연관된 자식도 함께 영속 상태로 만든다.

### 영속성 전이: 저장

엔티티 클래스에 연관관계 매핑하며 영속성 전이 활성화하는 CASCADE 옵션 적용.

```java
@Entity
public class Parent {
  ...
  @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
  private List<Child> children = new ArrayList<Child>();
  ...
}
```

부모만 영속화하면 `CascadeType.PERSIST`로 설정한 자식 엔티티까지 함께 영속화해서 저장한다. 영속성 전이는 연관관계 매핑과 관련X. **엔티티 영속화 편리함을 제공**한다. (양방향 연관관계를 추가(객체 참조)한 다음 영속 상태로 만들기)

### 영속성 전이: 삭제

엔티티를 삭제할 때도 영속성 전이를 사용할 수 있다. `CascadeType.REMOVE`로 설정하고 부모 엔티티만 삭제 하면 연관된 엔티티도 함께 삭제 된다. (DELETE SQL 실행, FK 제약조건 고려해 자식 먼제 삭제 후 부모 삭제)

### CASCADE 종류

```java
public enum CascadeType {
  ALL,
  PERSIST,
  MERGE,
  REMOVE,
  REFRESH,
  DETACH
}
```

`cascade = {속성1, 속성2}` 처럼 여러 속성 같이 사용 가능.

`CascadeType.PERSIST`와 `CascadeType.REMOVE`는 `em.persist()`, `em.remove()`를 실행할 때 바로 전이가 발생하지 않고 플러시를 호출할 때 전이가 발생한다.

## 고아 객체

JPA는 부모 엔티티와 연관관게가 끊어진 자식 엔티티(참조 삭제)를 자동 삭제하는 고아 객체 제거 기능을 제공한다.

`@OneToMany(mappedBy = "parent", orphanRemoval = true)`

고아 객체 제거 기능은 영속성 컨텍스트를 플러시할 때 적용되므로 플러시 시점에 DELETE SQL을 실행한다.(DB의 데이터가 제거됨)

고아 객체 제거 기능은 참조가 없는 객체를 제거 -> 참조하는 곳이 하나일 때만 사용 -> `orphanRemoval`은 `@OneToOne`, `@OneToMany`에만 사용 가능.

## 영속성 전이 + 고아 객체, 생명주기

`CascadeType.ALL`과 `orphanRemoval = true`를 동시 사용하면?

일반적으로 엔티티는 스스로 생명주기를 관리한다. (`em.persist()`, `em.remove()`) 그런데 두 옵션을 모두 활성화 하면 부모 엔티티를 통해 생명주기를 관리한다.

## 정리

- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 프록시 기술을 지원
- 객체 조회할 때 연관된 객체를 즉시 로딩 또는 지연 로딩 하도록 선택 가능
- 영속성 전이를 사용해 객체 저장 또는 삭제 시 연관된 객체도 함께 저장 또는 삭제
- 고아 객체 제거 기능으로 부모 엔티티와 연관관계가 끊어진 자식 엔티티 자동 삭제
