1장에선 요약이라 하지만 중요한 개념을 설명하고 있다. 왜 JPA를 사용해야하는지 .. 아주 간단하게 말하지만 
어쩌면 핵심을 요약한 장이 아닐까 생각한다. 
결국엔 객체지향 설계가 포인트다.
JPA도 불일치 패러다임을 객체지향적으로 해소하는 아주 똑똑한 방법인 것

왜 실무에서 테이블 설계는 다들 열심히 하면서 제대로 된 객체 모델링은 하지 않을까? -> 뼈맞음
왜 객체지향의 장점을 포기하고, 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하도록 개발할까?

객체와 관계형 데이터베이스의 차이를 메우기 위해 더 많은 sql을 작성해야 했다. -> 객체 모델은 점점 데이터 중심 모델로 변해간다.

JPA는 지루하고 반복적인 CRUD SQL을 알아서 처리해주고, 객체 모델링과 관계형 데이터베이스 사이의 차이점도 해결해줬다.
JPA를 사용해서 얻은 가장 큰 성과는 어플리케이션을 sql이 아닌 객체 중심으로 개발하니 생산성과 유지보수가 확연히 좋아지고, 테스트를 작성하기도 편리해진 점이다.  


# sql을 직접 다루면 발생하는 문제 
1. 진정한 의미의 계층 분할이 어렵다
2. 엔티티를 신뢰할 수 없다
3. sql에 의존적인 개발을 하게된다

### JPA와 문제 해결
JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 sql을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다. JPA가 개발자 대신 적절한 sql을 생성해서 데이터베이스에 전달한다.

# 패러다임 불일치
어플 커지면 -> 복잡성도 커진다. 지속가능한 app 개발하는 일은 끊임없이 증가하는 복잡성과의 싸움이고, 복잡성을 제대로 다루지 못하면
유지보수하기 어려운 앱이 된다.

객체지향 프로그래밍은 추상화,캡슐화,정보은닉,상속,다형성 등 시스템의 복잡성을 제어할 수 있는 장치들을 제공한다. 
그래서 현대의 복잡한 어플리케이션들은 대부분 객체지향 언어로 개발한다.

근데 이 때 문제가 생기는데..
바로 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다는 것이다.이게 바로 객체와 관계형 데이터베이스의 패러다임 불일치 문제다.

이거 개발자가 해결하려하면 오래걸리지만 JPA 사용하면 쉽게 해결됨 :)

![JPA 위치](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3Y5cy%2Fbtq1owL1vjU%2FSl1ZKRIPAGZLlfU4MWKKgk%2Fimg.png)



예를 들어
### 상속
객체에서 상속 기능 가지고 모델링했는데
데이터베이스 테이블에는 상속이라는 기능이 없다.
그나마 슈퍼타입, 서브타입 관계를 이용하여 객체 상속과 유사한 형태로 테이블을 설계할 수는 있다. 
이 과정에서 소모되는 비용이 있으니까 그걸 줄이고 싶은거지. 

### 그걸 JPA가 한다.
개발자는 마치 자바 컬렉션에 객체 저장하듯, JPA에 객체를 저장하면 된다! 

### 연관관계
객체는 참조를 사용해서 다른 객체와 연관관계를 가지고.. 참조에 접근해, 연관된 객체르 조회한다. 
반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용하여 연관테이블을 조회한다. 

-> 참조를 사용하는 객체 / 외래키를 사용하는 관계형 데이터베이스 사이의 패러다임 불일치 해소는 어렵다.
그니까, 논리적 디비 설계를 물리적 테이블 설계로 -> 개념적 설계로 가져올 때 우리 얼마나 힘들었는지 생각해바,..
재밌긴 하지만, 많은 개발자들이 이 과정에서 리소스를 쓴다는거지.

### 객체 그래프 탐색
객체지향 모델링을 통해 문제를 해결하려해도 개발자의 리소스는 든다. (P46-47에서 예제로 설명)
또한 객체지향 모델링으로 해결할 수 없는 문제도 있다. 바로 객체 그래프 탐색~


![객체 그래프 탐색](https://velog.velcdn.com/images%2Fbae12%2Fpost%2Ff7d60162-1578-486e-83c9-1292b744ec7d%2F%EA%B0%9D%EC%B2%B4%EA%B7%B8%EB%9E%98%ED%94%84%ED%83%90%EC%83%89.png)


SQL을 직접 다루면,, 처음 실행하는 sql에 따라 객체 그래프를 어디까지 탐색할지가 정해진다.
-> 그럼 개발자는 비지니스 로직에 따라 사용하는 객체 그래프가 다른데, 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수 없으므로 큰 제약이다. 

또한, member과 관련된 모든 객체 그래프를 디비에서 조회해서 애플리케이션 메모리에 올려두는 것은 현실성이 없다. MemberDAO애 회원을 조회하는 메소드를 상황에 따라 여러개 만들어 사용해야하는 상황이 된다.

실무에서는 수십게 이상의 엔티티들이 있는데, 모든 객체 그래프를 한번에 다 조회하게 되면 네트워크, 메모리, CPU 등등 모든 곳에 부담이 크다.실제 필요한 리소스보다 수십에서 수백배 이상의 리소스를 사용하게 된다.

### JPA는 지연로딩 (lazy loading)으로 이를 해결한다. 
JPA는 연관된 객체를 사용하는 시점에 적절한 SQL을 실행한다. 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다.
이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서, 지연로딩이라 한다. 필요한 시점에 sql 실행시켜서 신뢰성을 높여요

+ 객체에서 동일성 비교할 땐 , 주소값을 비교하면 다른 인스턴스로 인식
+ But JPA는 트랜잭션일 때 같은 객체가 조회되는 것을 보장함

## 정리
1. 객체 모델과 관계형 데이터베이스는 지향하는 패러다임이 서로 다르다. 문제는 이 차이점을 극복하기 위해 개발자가 너무 많은 시간을 쓰게 된다는 것. 
2. 더 어려운 문제는, 객체지향 애플리케이션답게 정교한 객체 모델링을 할수록 패러다임 불일치 문제가 커진다는 것이다. 이 틈을 메우기 위해 개발자🙋‍♀️ : "살려조요.."
3. 자바 진영에서는 이를 해결하기 위해 많은 노력을 기울여왔고 그 결과물이 JPA


## 개인적인 감상
응 결국엔 객체지향 설계하는데 객체랑 디비랑 싱크 맞추는거 너무 빡세고
그거 일일히 dao 만들어서 접근하고 외래키로 연관관계 맺고 등등 개발자들 힘든거 언제까지 할거냐!~~~ 해서 만들어진 것이 JPA!
객체 상속을 테이블에서 구현하려다 팀원과 힘들었던 경험.. 우리 모두가 있잔아요?


# JPA란 뭘까
ORM(Object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑 한다는 뜻이다. ORM 프레임워크는 객체와 테이블을 매핑 해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다. 그리고 둘을 어떻게 매핑 해야 하는지 매핑 방법만 ORM 프레임워크에게 알려주면 된다.

## 왜 JPA를 써야할까
- 생산성 : 이전에 DAO에서 작업하던 지루하고 반복적인 일은 JPA가 대신 처리 해준다. 이런 기능들을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.
- 유지보수 : 이전엔 엔티티 필드 하나만 수정해도 관련된 DAO 로직의 SQL문을 모두 변경해야 했다. 반면에 JPA는 대신 처리해주므로 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어든다.
- 패러다임 불일치 해결
- 성능 : JPA는 애플리케이션과 데이터베이스 사이에 동작하여 최적화 관점에서 시도해 볼 수 있는 것들이 많다. 예를 들어 동일한 조건으로 조회 했을 경우엔 SELECT SQL을 한 번만 데이터베이스에 전달하고 두 번째 조회한 회원 객체는 재사용할 수 있다.
- 데이터 접근 추상화 & 벤더 독립성 : 관계형 데이터베이스는 같은 기능도 벤더 마다 사용법이 다른 경우가 많다. 단적인 예로 페이징 처리는 데이터베이스마다 달라서 사용법을 각각 배워야 한다. 결국 애플리케이션은 데이터베이스에 종속되어 변경 하기는 매우 어렵다. **JPA는 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 할 수 있다.**

## N+1?
예를 들어 sql 1번으로 회원 100명을 조회했는데 각 회원마다 주문한 상품을 추가로 조회하기 위해 100번의 sql을 추가로 실행하는 것을 말한다.
한번 sql을 실행해서 조회한 수만큼 N번 sql을 추가로 실행한다고 해서 N+1 문제라고 한다. JPA 약간만 공부하면 쉽게 해결할 수 있다





