# 3. 영속성 관리

## 엔티티 매니저 팩토리와 엔티티 매니저

#### 엔티티 매니저

매핑한 엔티티는 엔티티 매니저를 통해 사용한다.  
엔티티 매니저는 엔티티와 관련된 모든 일을 처리하는 관리자로 가상의 데이터베이스라 생각하면 된다.

- 생성 비용: 생성 비용이 거의 들지 않는다.
- 스레드 동시 접근: 여러 스레드가 동시에 접근하면 동시성 문제 발생(내부에서 DB 커넥션 관리) -> 스레드간 공유X

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.

- 보통 트랜잭션 시작할 때 커넥션 획득
- 하이버네이트는 엔티티 매니저 팩토리 생성할 때 커넥션풀 생성(Java SE 환경)
- 컨테이너가 제공하는 데이터소스 사용(J2EE)

#### 엔티티 매니저 팩토리

데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 하나의 EntityManagerFactory를 생성한다.  
엔티티매니저팩토리는 `persistence.xml`을 바탕으로 생성된다.

- 생성 비용: 생성 비용이 상당히 크다.
- 스레드 동시 접근: 여러 스레드가 동시에 접근해도 안전(emf는 하나만 만들어 애플리케이션 전체에서 공유)

## 영속성 컨텍스트 Pertistence Context

엔티티를 영구 저장 하는 환경이다.  
엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저가 영속성 컨텍스트에 엔티티를 보관하고 관리한다.  
엔티티 매니저를 생성할 때 하나 만들어진다.

## 엔티티 생명주기

#### 엔티티 상태

- **비영속(new/transient)**: 영속성 컨텍스트와 관계 없는 상태
  - 엔티티 객체가 생성된 상태, 순수한 객체 상태
- **영속(managed)**: 영속성 컨텍스트에 저장된 상태
  - 영속 상태 -> 영속성 컨텍스트가 관리하는 상태
  - em.persist() 호출 후
- **준영속(detached)**: 영속성 컨텍스트에 저장 되었다가 분리된 상태
  - em.detach()
  - em.close()
  - em.clear()
- **삭제(removed)**: 삭제된 상태
  - 엔티티를 영속성 컨텍스트와 DB에서 삭제

## 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값**  
  영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
- **영속성 컨텍스트와 데이터베이스 저장**  
  JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 변경된 내용을 데이터베이스에 반영한다. -> 플러시(flush)

### 영속성 컨텍스트 통한 엔티티 관리 장점

#### 1차 캐시

영속성 컨텍스트 내부에 있는 캐시 공간으로 영속 상태의 엔티티가 저장 된다. (key, value 형태)

em.find()로 엔티티 조회

1. 1차 캐시에서 엔티티 조회
2. 1차 캐시에 없으면 데이터베이스를 조회 -> 엔티티 생성 -> 1차 캐시에 저장 -> 영속 상태의 엔티티 반환
   => 성능 향상

#### 동일성 보장

영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.  
 -> 식별자가 같은 엔티티 조회 시 같은 엔티티 인스턴스를 반환

#### 트랜잭션을 지원하는 쓰기 지연 transactional write-behind

엔티티 매니저는 트랜잭션을 커밋하기 전에는 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 SQL을 모아둔다. 트랜잭션을 커밋하면 쓰기 지연 SQL 저장소에 있는 모아둔 쿼리를 데이터베이스에 보낸다.  
 트랜잭션 커밋 전 엔티티 매니저가 영속성 컨텍스트를 **플러시**한다.

- 플러시: 영속성 컨텍스트의 변경 내용을 DB에 동기화(반영)
  => 성능 최적화

#### 변경 감지 dirty checking

엔티티의 데이터를 변경하면 JPA가 엔티티의 변경사항을 감지해 데이터베이스에 자동으로 반영하는 기능이다.

변경 사항 감지 방법:

1. JPA가 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장(스냅샷)
2. **플러시 시점에 스냅샷과 엔티티 비교**해 변경된 엔티티 찾기
3. 변경된 엔티티가 있으면 **수정 쿼리를 생성**해 쓰기 지연 SQL 저장소에 보냄
4. 저장소의 SQL을 DB에 보냄
5. 트랜잭션 커밋

- JPA는 엔티티 중심 기술 -> 변경 감지 시 엔티티의 모든 필드를 업데이트
  - 수정 쿼리가 항상 같아 재사용할 수 있다.
  - DB에 동일한 쿼리를 보내면 이전에 파싱된 쿼리를 재사용할 수 있다.

=> 수정 쿼리가 SQL에 의존하지 않도록 한다. (SQL에 의존: 상황에 따라 수정 쿼리를 계속 추가, 비즈니스 로직 분석 위해 SQL 직접 확인.)

> **동적 수정 쿼리 사용**  
> @org.hibernate.annotations.DynamicUpdate  
>  필드가 많거나 저장 내용이 크면 수정된 데이터만 사용해 동적으로 UPDATE SQL을 생성  
> @DynamicInsert  
>  데이터를 저장할 때 데이터가 존재하는 필드만으로 INSERT SQL을 동적으로 생성

#### 지연 로딩 Lazy Loading

실체 객체 대신 프록시 객체를 로딩해두고 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.

## 플러시 flush()

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 기본값은 커밋 또는 쿼리 실행시 플러시. (플러시 모드 옵션 직접 지정 가능)

#### 플러시 하는 방법

- em.flush() 직접 호출
- 트랜잭션 커밋 시 플러시 자동 호출
- JPQL 쿼리 실행 시 플러시 자동 호출

## 준영속

준영속 상태의 엔티티는 식별자 값을 가지고 있으며, 영속성 컨텍스트가 제공하는 기능들을 사용할 수 없다...! _(1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등의 기능 사용X)_

### 영속 -> 준영속 상태 전환

1. em.detach(entity): 특정 엔티티만 전환. 호출시 해당 엔티티와 관련된 1차 캐시, 쓰기 지연 SQL 저장소 정보가 제거된다.
2. em.clear(): 영속성 컨텍스트를 초기화. 모든 엔티티를 준영속 상태로 만든다.
3. em.close(): 영속성 컨텍스트를 종료.(자주 사용) 해당 영속성 컨텍스트가 관리하는 모든 엔티티가 준영속 상태가 된다.

### 병합 merge()

#### 준영속 병합(준영속 -> 영속)

merge()로 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환.

1. merge() 실행
2. 파라미터로 넘겨 받은 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회.
   - 1차 캐시에 엔티티가 없으면 DB에서 엔티티를 조회하고 1차 캐시에 저장.
3. 조회한 영속 엔티티에 파라미터의 준영속 엔티티의 값을 채워 넣는다.
4. 새로 만들어진 영속 엔티티를 반환.

#### 비영속 병합(비영속 -> 영속)

merge()로 비영속 상태의 엔티티도 영속 상태로 만들 수 있다.

1. merge() 실행
2. 파라미터로 받은 비영속 엔티티의 식별자 값으로 영속성 컨텍스트 조회.
   - 영속성 컨텍스트에 찾는 엔티티가 없으면 DB에서 조회.
   - DB에도 없으면 새로운 엔티티를 생성해 반환. (save or update)
