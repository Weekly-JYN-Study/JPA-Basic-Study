# 9. 값 타입

JPA의 데이터 타입

- **엔티티 타입**
- **값 타입(Value Type)**
  - 기본값 타입 basic value type
    - 자바 기본 타입(int, double)
    - 래퍼 클래스
    - String
  - 임베디드 타입 embedded type
  - 컬렉션 값 타입 collection value type

## 기본값 타입

값 타입은 식별자 값도 없고 생명주기도 엔티티에 의존한다. (엔티티 인스턴스 제거시 같이 제거됨) 값 타입은 공유하면 안 된다. (이름 필드 다른 사람이 변경...X)

_엔티티는 식별자 있고 생명주기 있음(영속성 컨텍스트)_

## 임베디드 타입(복합 값 타입)

JPA에서 새로운 값 타입을 직접 정의해서 사용하는 것을 임베디드 타입이라 한다. 임베디드 타입도 int, String 처럼 **값 타입**이다.

#### 임베디드 타입 사용 이유

_객체지향 개발 위해 사용한다!_

엔티티가 상세한 데이터를 그대로 가지는 것은 객체지향적이지 않고 응집력이 낮다.

대신 임베디드 타입을 사용해 코드를 더 명확히 만들면 좋다.

임베디드 값 타입은 재사용할 수 있고 응집도도 높다. 또한 해당 값 타입만 사용하는 의미 있는 메소드도 만들 수 있다.

#### 임베디드 타입 사용 예시

- 상세한 데이터 가지는 회원 엔티티: 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편 번호
- 임베디드 타입 사용하는 회원 엔티티: 이름, 근무기간 타입, 주소 타입

#### 임베디드 타입 사용하기

- `@Embeddable`: 값 타입 정의하는 곳
- `@Embedded`: 값 타입 사용하는 곳

둘 중 하나 생략 가능.

임베디드 타입은 기본 생성자 필수.

#### 엔티티와 임베디드 타입 관계

임베디드 타입 포함한 모든 값 타입은 엔티티 생명주기에 의존하므로 엔티티와 임베디드 타입의 관계를 UML로 표현하면 **컴포지션 관계 composition** 다.

### 임베디드 타입과 테이블 매핑

임베디드 타입은 엔티티의 값 -> 값 속한 엔티티 테이블에 매핑 -> 임베디드 타입 사용 전 후 매핑하는 테이블 같음

=> 임베디드 타입 사용으로 객체와 테이블 세밀하게 매핑 가능.  
(잘 설계한 ORM 애플리케이션은 매핑 테이블 수 보다 클래스 수가 더 많다.)

### 임베디드 타입과 연관관계

임베디드 타입은 값 타입을 포함 하거나 엔티티 참조 _(연관관계 설정)_ 가능.

> 엔티티는 공유 가능 -> '참조'
> 값 타입은 특정 주인에 소속, 공유X -> '포함'

### @AttributeOverride: 속성 재정의

임베디드 타입에 정의한 매핑정보를 재정의 하려면 엔티티에 `@AttributeOverride`를 사용하면 된다. _(임베디드 타입 중복 시 사용)_ -> 그런데 한 엔티티에 같은 임베디드 타입 중복 사용 하는 경우 잘 없음

### 임베디드 타입과 null

임베디드 타입이 null 이면 매핑한 컬럼 값은 모두 null이 된다. (관련된 컬럼들 null)

## 값 타입과 불변 객체

값 타입은 복잡한 객체 세상을 단순화한다. -> 값 타입은 단순. 안전하게 다루기

### 값 타입 공유 참조

임베디드 타입 같은 값 타입은 여러 엔티티에서 공유하면 위험하다. -> **공유 참조 버그**가 발생한다. -> 예상치 못한 곳에서 문제 발생하는 것은 부작용(side effect)

이런 공유 참조 부작용을 막으려면 값을 복사해서 사용하면 된다.

### 값 타입 복사

값 타입의 실제 인스턴스 값 공유 하는 대신 항상 값(인스턴스)을 복사해서 사용해야 한다. (`clone()` 자신 복사해 반환)

**문제**: 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본타입 (primitive type)이 아니라 **객체 타입**이라는 것.

자바는 기본 타입에 값 대입 시 값 복사해 전달. 객체 타입이면 객체에 값 대입 시 참조 값을 전달. -> 복사 않고 **원본 참조 값을 직접 넘기는 것을 막는 방법이 없음**

=> 객체의 공유 참조는 피할 수 없다.  
=> 객체 값 수정하지 못하도록 하는 방법 필요  
=> 객체의 수정자 메소드 모두 제거하기!

### 불변 객체

객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용을 원천 차단한다. 값 타입은 불변 객체(Immutable Object)로 설계해야 한다.

불변 객체를 구현하는 다양한 방법 중 **생성자로만 값을 설정하고 수정자를 만들지 않으면 되는 간단한 방법**을 사용하면 된다.

> Integer, String은 자바 제공 대표 불변 객체~

=> 불변이라는 제약으로 부작용을 막을 수 있다!

## 값 타입의 비교

#### 자바 제공 객체 비교

- 동일성(Identity) 비교: 인스턴스 참조 값 비교, `==` 사용
- 동등성(Equivalence) 비교: 인스턴스 값 비교, `equals()` 사용

#### 값 타입 비교 하기

값 타입을 비교할 때는 값 타입의 `equals()`, `hashCode()` 메소드를 재정의해 동등성 비교하기. _값 타입은...객체 타입 이니까..._

## 값 타입 컬렉션

값 타입을 하나 이상 저장 시 컬렉션에 보관하고 `@ElementCollection`, `@CollectionTalbe` 어노테이션을 사용하면 된다.

#### 엔티티와 값 타입 컬렉션

관계형 데이터베이스 테이블은 컬럼안에 컬렉션을 포함할 수 없다. 따라서 별도의 테이블을 추가하고 `@CollectionTable`을 사용해 추가한 테이블을 매핑한다. 값으로 사용되는 컬럼이 하나면 `@Column`으로 컬럼명 지정.

### 값 타입 컬렉션 사용

엔티티에 값 _(임베디드 값 타입, 기본값 타입 컬렉션, 임베디드 값 타입 컬렉션)_ 을 등록하고 마지막에 엔티티만 영속화하면 JPA가 엔티티의 값 타입도 함께 저장 한다.

엔티티 영속화 한 번으로 JPA가 실제 DB에 각각 등록한 값의 INSERT SQL을 실행해준다.

> 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거(ORPHAN REMOVE) 기능을 필수 사용

값 타입 컬렉션도 조회 시 페치 전략을 선택할 수 있다.(기본값: LAZY)

### 값 타입 컬렉션의 제약사항

#### 값 타입 컬렉션 값 변경

문제: 값 타입은 식별자 개념이 없고 단순한 값들의 모음이므로 값을 변경하면 DB에 저장된 원본 데이터를 찾기 어렵다. -> 별도의 테이블에 값을 보관하는 값 타입 컬렉션도 마찬가지이다.

해결 방법: JPA 구현체들은 값 타입 컬렉션에 변경 사항이 발생하면, 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고, 현재 값 타입 컬렉션 객체에 있는 모든 값을 DB에 다시 저장한다.

-> 실무에서 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다.

#### 값 타입 컬렉션 매핑 테이블 기본 키

값 타입 컬렉션 매핑 테이블 기본 키는 모든 컬럼을 묶어서 구성해야 한다. 따라서 DB 기본 키 제약 조건으로 컬럼에 NULL 입력X, 값 중복 저장X 제약이 있다.

-> 값 타입 컬렉션 사용 대신 새로운 엔티티 만들어 일대다 관계로 설정, 영속성 전이 + 고아 객체 제거 기능 적용. 값 타입 컬렉션처럼 사용하기!

## 정리

엔티티 타입과 값 타입의 차이와 관계 이해하기... 값 타입의 특징 알아보기...값 타입은 객체지향 설계를 위해 사용한다...값 타입은 불변 객체로 만들어야 한다...!

엔티티와 값 타입 혼동 말고, 값 타입은 정말 값 타입이라 판단될 때만 사용하기! -> 식별자가 필요하고 지속적인 값 추적 필요 시 엔티티 사용

가능하면 제약 사항이 있는 값 타입 대신 새로운 엔티티로 대체해 사용하기.
